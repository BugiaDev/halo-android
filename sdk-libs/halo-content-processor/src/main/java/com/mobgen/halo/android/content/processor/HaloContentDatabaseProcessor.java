package com.mobgen.halo.android.content.processor;

import com.google.auto.service.AutoService;
import com.mobgen.halo.android.content.annotations.HaloQuery;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.JavaFileObject;

@AutoService(Processor.class)
@SupportedAnnotationTypes({"com.mobgen.halo.android.content.annotations.HaloQuery",
        "com.mobgen.halo.android.content.annotations.HaloField",
        "com.mobgen.halo.android.content.annotations.HaloSearchable"})
@SupportedSourceVersion(SourceVersion.RELEASE_7)
public class HaloContentDatabaseProcessor extends AbstractProcessor {

    private Types typeUtils;
    private Elements elementUtils;
    private Filer filer;
    private Messager messager;

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        typeUtils = processingEnv.getTypeUtils();
        elementUtils = processingEnv.getElementUtils();
        filer = processingEnv.getFiler();
        messager = processingEnv.getMessager();
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        Set<String> annotataions = new LinkedHashSet<String>();
        annotataions.add(HaloQuery.class.getCanonicalName());
        return annotataions;
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latestSupported();
    }


    @Override
    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {
        generateHaloQueryClass(roundEnvironment);
        generateHaloFieldClass(roundEnvironment);
        generateHaloSearchableClass(roundEnvironment);
        return true;
    }

    private void generateHaloQueryClass(RoundEnvironment roundEnvironment){
        JavaFile javaFile=null;
        String className = "HaloGeneratedQuery";
        TypeSpec.Builder queryClassBuilder = TypeSpec.classBuilder(className);
        queryClassBuilder.addModifiers(Modifier.PUBLIC);
        queryClassBuilder.addJavadoc("This class was autogenerated to perfom queries.");

        //add all annotated query elements
        for (Element element : roundEnvironment.getElementsAnnotatedWith(HaloQuery.class)) {

            String query = element.getAnnotation(HaloQuery.class).query();
            String methodName = element.getAnnotation(HaloQuery.class).name();

            MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName)
                    .addJavadoc("Query by codegen: "+ query)
                    .addModifiers(Modifier.PRIVATE);

            for(int i=0;i<query.length();i++){
                if(query.charAt(i) == '?'){
                    String param = query.substring(i+1);
                    methodBuilder.addParameter(resolveDataType(param.substring(param.indexOf(":")+1,param.indexOf(" "))),param.substring(0,param.indexOf(":")));
                    query = query.replace("?" + param.substring(0,param.indexOf(" ")+1),"? ");
                }
            }
            methodBuilder.addStatement("String query = $S",query)
                    .returns(String.class)
                    .addStatement("return $S",query);

            MethodSpec queryDatabase = methodBuilder.build();
            queryClassBuilder.addMethod(queryDatabase);
        }
        TypeSpec queryClass = queryClassBuilder.build();

        javaFile = JavaFile.builder("com.mobgen.halo.content.generated", queryClass)
                .build();

        try {
            JavaFileObject source = processingEnv.getFiler().createSourceFile("com.mobgen.halo.content.generated." + className);
            Writer writer = source.openWriter();
            writer.write(javaFile.toString());
            writer.flush();
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void generateHaloFieldClass(RoundEnvironment roundEnvironment){

    }

    private void generateHaloSearchableClass(RoundEnvironment roundEnvironment){

    }

    private Class resolveDataType(String type) {
        if(type.equals("String")){
            return String.class;
        } else if(type.equals("Integer")){
            return Integer.class;
        } else {
            return Object.class;
        }
    }

//    public void testWithJavaPoet(RoundEnvironment roundEnvironment){
//        JavaFile javaFile=null;
//        String className = "";
//
//        for (Element element : roundEnvironment.getElementsAnnotatedWith(HaloQuery.class)) {
//
//            String query = element.getAnnotation(HaloQuery.class).query();
//            className = element.getAnnotation(HaloQuery.class).name();
//
//            MethodSpec run = MethodSpec.methodBuilder("run")
//                    .addModifiers(Modifier.PUBLIC)
//                    .returns(void.class)
//                    .addStatement("$T.out.println($S)", System.class, "inner runs in a thread")
//                    .addAnnotation(Override.class)
//                    .build();
//            TypeSpec anonRunnable = TypeSpec.anonymousClassBuilder("")
//                    .addSuperinterface(Runnable.class)
//                    .addMethod(run)
//                    .build();
//            MethodSpec runInner = MethodSpec.methodBuilder("runInner")
//                    .addModifiers(Modifier.PUBLIC)
//                    .addStatement("new $T($L)", Thread.class, anonRunnable).build();
//            TypeSpec inner = TypeSpec.classBuilder("Inner")
//                    .addMethod(runInner)
//                    .build();
//            MethodSpec outerConstructor = MethodSpec.constructorBuilder()
//                    .addParameter(String.class, "str", Modifier.FINAL)
//                    .addStatement("$T.out.println($S+$N)", System.class, "outer created with ", "str")
//                    .addModifiers(Modifier.PUBLIC)
//                    .build();
//            MethodSpec greetCustomer = MethodSpec.methodBuilder("greetCustomer")
//                    .addModifiers(Modifier.PUBLIC)
//                    .returns(String.class)
//                    .addParameter(String.class, "query")
//                    .addStatement("return $S+$N", "Welcome, ", "query").build();
//            MethodSpec count = MethodSpec.methodBuilder("count")
//                    .addModifiers(Modifier.PRIVATE)
//                    //.addCode("int total=0;")
//                    .addParameter(TypeName.INT,"total")
//                    .beginControlFlow("for (int i = 0; i < 10; i++)")
//                    .addStatement("total += i")
//                    .endControlFlow().build();
//            MethodSpec ifmethod =MethodSpec.methodBuilder("isDelicious")
//                    .addParameter(TypeName.INT, "count")
//                    .returns(TypeName.BOOLEAN)
//                    .beginControlFlow("if (count > 0)")
//                    .addStatement("return true")
//                    .nextControlFlow("else")
//                    .addStatement("return false")
//                    .endControlFlow()
//                    .build();
//            AnnotationSpec path = AnnotationSpec.builder(HaloField.class)
//                    .addMember("index","true")
//                    .build();
//            FieldSpec myawesomefield = FieldSpec.builder(String.class, "myawesomefield")
//                    .initializer("$S",".")
//                    .addModifiers(Modifier.PROTECTED, Modifier.FINAL, Modifier.STATIC)
//                    .build();
//            MethodSpec queryDb = MethodSpec.methodBuilder("queryDb")
//                    .addAnnotation(path)
//                    .addJavadoc("This is a nice Javadox")
//                    .returns(String.class)
//                    .addParameter(String.class,"query")
//                    .addStatement("return $S+$S","the query to perfom is...",query).build();
//            MethodSpec printliteral = MethodSpec.methodBuilder("printliteral")
//                    .returns(int.class)
//                    .addStatement("int result = 0")
//                    .beginControlFlow("for (int i = $L; i < $L; i++)", 0, 10)
//                    .addStatement("result = result $L i", "*")
//                    .endControlFlow()
//                    .addStatement("return result")
//                    .build();
//            TypeSpec outer = TypeSpec.classBuilder(className)
//                    .addField(myawesomefield)
//                    .addMethod(outerConstructor)
//                    .addMethod(greetCustomer)
//                    .addMethod(count)
//                    .addMethod(queryDb)
//                    .addMethod(ifmethod)
//                    .addMethod(printliteral)
//                    .addType(inner)
//                    .build();
//            javaFile = JavaFile.builder("com.mobgen.halo.content.generated", outer)
//                    .build();
//
//        }
//
//        try {
//            JavaFileObject source = processingEnv.getFiler().createSourceFile("com.mobgen.halo.content.generated." + className);
//            Writer writer = source.openWriter();
//            System.out.println("=====>>>>>>>Table name "+ javaFile.toString());
//            writer.write(javaFile.toString());
//            writer.flush();
//            writer.close();
//        } catch (IOException e) {
//            e.printStackTrace();
//        }
//    }
}
